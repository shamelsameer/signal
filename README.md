# Extending the Signal Project to Use Post-Quantum Cryptography

## Prerequisite Knowledge
Our project was inspired by two main protocols: the Goldreich, Goldwasser, and Halevi (GGH) scheme[2] and the Kyber scheme.[1] GGH is a post-quantum secure cryptosystem based on hard lattice problems, while Kyber is a post-quantum cryptosystem based on the Ring-LWE (learning with errors) cryptographic assumption. In both cases, the hard lattice problem and the Ring-LWE assumption, we can assume a particular kind of problem that is difficult to solve even for quantum computers. This contrasts with the computational Diffie-Hellman assumption, which does not hold for quantum computers: a quantum computer can easily break Diffie-Hellman key exchange using Shor's algorithm.

### GGH
First, we will consider the GGH scheme. From this scheme we borrowed the public key infrastructure with the following steps:
* Key Generation
    1. Alice chooses a set of linearly independent vectors $\mathbf{v}_1,\dots,\mathbf{v}_n \in \mathbb{Z}^n$. These are her secret key.
    2. Alice chooses a random integer matrix $U$ such that $\det(U) = \pm 1$.
    3. Let $V \in \mathbb{Z}^{n \times n}$ be the matrix whose row vectors are $\mathbf{v}_1,\dots,\mathbf{v}_n$. Alice computes $W=UV$.
    4. Alice publishes the row vectors $\mathbf{w}_1,\dots,\mathbf{w}_n$ of $W$. These are her public key.
* Encryption
    1. Bob chooses a small plaintext vector $\mathbf{m} \in \mathbb{Z}^n$ as his message.
    2. Bob chooses a small random vector $\mathbf{r} \in \mathbb{Z}^n$.
    3. Bob computes $\mathbf{e} = \mathbf{m}W+\mathbf{r}$ as his ciphertext and sends it to Alice.
* Decryption
    1. Alice uses Babai's algorithm (which we discuss next) to find the vector $\mathbf{v} \in L$ closest to $\mathbf{e}$, where $L$ is the lattice generated by the vectors $\mathbf{v}_1,\dots,\mathbf{v}_n$.
    2. Alice computes $\mathbf{v}W^{-1}$. Since $\mathbf{e} \approx \mathbf{v} \approx \mathbf{m}W$, this recovers the message $\mathbf{m}$.

Note that the decryption depends on Babai's algorithm and some approximation. Since Alice has the secret key $\mathbf{v}_1,\dots,\mathbf{v}_n$, she will be able to run this algorithm accurately and recover the original message. However, if an adversary Eve tries to run the algorithm without the secret key, the approximation will be poor and she will fail to recover $\mathbf{m}$.[2]

### Babai's algorithm
Babai's algorithm is an algorithm for finding the nearest lattice point to a vector. It is very simple. First, we express the vector $\mathbf{w} \in \mathbb{R}^n$ using basis vectors $\mathbf{v_1},\dots,\mathbf{v_n}$ as
$$\mathbf{w} = t_1\mathbf{v_1}+\dots+t_n\mathbf{t_n}$$
Then we round all the coefficients $t_i \in \mathbb{R}$ to the nearest integer $a_i \in \mathbb{Z}$. What we get is a new vector
$$\mathbf{v} = a_1\mathbf{v}_1 + \dots + a_n\mathbf{v}_n$$
that is close to the original vector $\mathbf{w}$. It is important to note that the success of this algorithm depends on the basis vectors used. This can be predicted by the Hadamard ratio
$$\left(\frac{\det(L)}{|\mathbf{v}_1|\cdot\dots\cdot|\mathbf{v}_n|}\right)^{1/n}$$
where $L$ is the lattice matrix produced by the row vectors in the basis. GGH uses a basis with a high Hadamard ratio as a secret key, and uses a basis with a low Hadamard ratio as a public key. This way, the party with the secret key can successfully find a nearby lattice point even in the presence of random noise, recovering the message. An adversary, who only has the public basis, will likely not recover the message. However, it is important to note that this depends on the noise in the input, and it is possible for this algorithm to fail.[2]

### Kyber
From Kyber we borrowed the key encapsulation mechanism (KEM). This is a method where given a secure public key encryption and decryption scheme, Alice and Bob can agree on a shared secret in a way that does not leak information to an adversary. The original Kyber protocol used their own encryption and decryption scheme,[1] but we substituted this for ElGamal and later the post-quantum secure GGH. The Kyber KEM has the following steps:
* First, Alice simply sends her public key $\mathrm{pk}$ to Bob in the clear.
* Encapsulation
    1. Bob generates a random message $\mathbf{m} \in \{0,1\}^{256}$.
    2. Bob computes $(\hat{K},r,d) := G(\mathrm{pk},m)$ where $G$ is a hash function.
    3. Bob generates a ciphertext $c$ by encrypting $m$ using randomness $r$.
    4. Bob computes the shared secret $K:=H(\hat{K}, c)$.
    5. Bob sends the ciphertext $c$ to Alice. Bob wants Alice to use $c$ and her secret key to reconstruct $\hat{K}$ and then $K$.
* Decapsulation
    1. Alice uses her secret key to decrypt the ciphertext $\mathbf{u}$ sent by Bob, giving her plaintext $m^\prime$.
    2. Alice computes $(\hat{K}^\prime, r^\prime, d^\prime) := G(\mathrm{pk},m^\prime)$.
    3. Alice computes $\mathbf{u}^\prime$ as the encryption of $m^\prime$ using randomness $r^\prime$.
    4. If $\mathbf{u}^\prime = \mathbf{u}$ and $d^\prime = d$, Alice computes the shared secret $K:=H(\hat{K}^\prime, c)$. Otherwise, she computes a pseudo-random shared secret $K:=H(z,c)$.

# Project Overview
Implementing these schemes in practice requires a few details beyond the mathematics detailed above. For GGH, we need a method to generate the linearly independent vectors of the secret key. We can do this by choosing the components of $\mathbf{v}_1,\dots,\mathbf{v}_n$ randomly from $-d$ to $d$ for a fixed parameter $d=400$. We can verify that the choice of vectors is good using the Hadamard ratio[2] which measures the orthognality of of a basis for a lattice. In our project, we required the basis to have a Hadamard ratio of at least 0.75.

The next concern is generating the matrix $U$. We can do this by multiplying by a large number of elementary matrices.[2] In our project, we did this using two row operations: one was row swapping, and the other was adding a multiple $\lambda$ of a row to another row where $\lambda \in -21,\dots,21$. This ensures that if we start with the identity matrix, the determinant of the resulting matrix $U$ is always $\pm 1$.

For generating the random noise, we chose a parameter $\delta=21$ so each component of the noise vector $\mathbf{r}$ is in $-21,\dots,21$. When we combined the GGH scheme with Kyber KEM, we used this noise vector $\mathbf{r}$ as the randomness $r$ in encryption.

For the hash functions used in Kyber KEM, we used SHA-256. Depending on the sizes of inputs and outputs we sometimes split hashes into multiple substrings.

Finally, the dimension of our vectors in GGH was $16$. This is so that we could make each component of the message $\mathbf{m}$ in $-2^{15},\dots,2^{15}-1$ so each component has $16$ bits of information. $16\cdot16=256$ bringing us to the total of $256$ bits used for the random message in Kyber.
With these details in mind, here is a more general overview of our project:
* We created a GGH driver that handles GGH key generation, encryption, and decryption.
* We allowed the crypto driver to access this GGH driver in order to encrypt and decrypt using GGH during the Kyber KEM.
* When we run the signal app, the two parties Alice and Bob run the Kyber KEM in order to agree on a shared secret. They use GGH for encryption and decryption rather than the Kyber equivalents.
* In the end, Alice and Bob have a shared secret and can proceed with Signal the same as before.

# Difficulties
Originally, we planned to do everything with Kyber. When we integrated the Kyber KEM into Signal, we used ElGamal encryption and decryption as a temporary placeholder. This worked, so we moved on to test Kyber encryption and decryption in `numpy`. This worked, but it was quite difficult because Kyber relies on polynomial rings, cyclotomic polynomials, and other difficult concepts in abstract algebra. While we were able to figure all of this out in `numpy`, the documentation for polynomials and rings in CryptoPP was very poor. There was no information on the CryptoPP wiki either.

This pushed us to switch to GGH encryption and decryption instead. However, even this was difficult in CryptoPP because all the documentation we could find related to integers only, and GGH uses some real numbers with Babai's algorithm. Additionally, since GGH relies on linear algebra concepts such as matrix inversion, we did not want to implement everything from scratch in CryptoPP. To solve this problem, we turned to the Eigen library for linear algebra in C++.

We were able to get GGH working with Eigen. However, there were still some difficulties. The ultimate cause of most of these issues is that rather than using a ring, GGH uses vectors in $\mathbb{Z}^n$. This can quickly lead to overflow errors if the parameters are not chosen carefully. We had to balance the risk of overflow, the desire for greater security, and the ability to connect our encryption and decryption with Kyber. Part of the solution was using `long double` rather than simply `double` so we could use larger numbers.

Even when GGH was working, there were issues connecting it with the rest of the scheme. In particular, we had to convert formats between Eigen and CryptoPP in a way that was reliable but also did not take too much space. In the end, we used two distinct methods. One of these was more compact for the message $\mathbf{m} \in \{0,1\}^{256}$ where we knew exactly how many bits would be needed for the message, so we were able to convert the message vector to a `SecByteBlock` that is as small as possible. However, we also needed to send and work with much larger GGH objects, such as the public key $W \in \mathbb{Z}^{n \times n}$. Since the size of a `long double` in C++ is 16 bytes, this required a `SecByteBlock` of $16n^2$ bytes. It was difficult to keep track of the different formats and debug them. We had a strange bug where we had to call GGH decryption twice with the same parameters, or else there were slight issues with the `SecByteBlock` size and data. Since we use hash functions in the encapsulation, these slight issues were enough to throw the entire protocol off as the two parties ended up with different shared secrets.

# Experiments and Benchmarks
After implementing quantum security in Signal, we ran the project locally. The two parties were successfully able to communicate, indicating that the protocol succeeded.

Another benchmark we did was with the `eigentest()` function in the GGH driver. This function includes extensive testing of the GGH protocol using both examples from the *An Introduction to Mathematical Cryptography* textbook by Hoffstein, Pipher, and Silverman[2] and randomly generated examples made to be compatible with Kyber. We referred to the outputs of this function while developing the GGH driver, and also while integrating its functionality into the project as a whole. This function, while unused in our final implementation, includes
* A full test of the GGH example used in the textbook[2]
* A test of GGH with the actual parameters we used in our project
* Tests of conversions between `SecByteBlock`s and vectors of the Eigen library
* Demonstrations that an adversary is not able to decrypt the message in our protocol
The function includes `std::cout` statements to see and compare outputs of various functions. Originally we had called it in our main method, but once everything was working we commented this out so it would not be distracting when running our final project.

# References
[1] Joppe Bos et al. CRYSTALS – Kyber: a CCA-secure module-lattice-based KEM. 2017.

[2] Jeffrey Hoffstein, Jill Pipher, and Joseph H. Silverman. An Introduction to Mathematical Cryptography. 2014.
